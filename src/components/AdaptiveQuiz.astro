---
import MultipleChoice from "./MultipleChoice.astro";
import { getGenerator } from "../lib/generators";

interface Props {
  generator: string;
  baseSeed: number;
  initialCount?: number;
  appendCount?: number;
  maxQuestions?: number;
}

const {
  generator: generatorType,
  baseSeed,
  initialCount = 2,
  appendCount = 2,
  maxQuestions = 10,
} = Astro.props;

// Generate unique problems at build time
// Try more seeds than maxQuestions to maximize chances of filling the pool
const generator = getGenerator(generatorType);
const seen = new Set<string>();
const problems: ReturnType<typeof generator.generate>[] = [];
const maxAttempts = maxQuestions * 5; // Try up to 5x seeds to find unique questions

for (let i = 0; i < maxAttempts && problems.length < maxQuestions; i++) {
  const problem = generator.generate(baseSeed + i);
  // Use question text as uniqueness key (strips HTML for consistent comparison)
  const key = problem.question.replace(/<[^>]*>/g, '').trim();
  if (!seen.has(key)) {
    seen.add(key);
    problems.push(problem);
  }
}
// If pool exhausted before maxQuestions, problems.length < maxQuestions - that's fine
---

<div
  class="adaptive-quiz"
  data-initial-count={initialCount}
  data-append-count={appendCount}
>
  <div class="quiz-questions">
    {
      problems.map((problem, i) => (
        <div
          class:list={["quiz-question-wrapper", { hidden: i >= initialCount }]}
          data-index={i}
        >
          <MultipleChoice
            question={problem.question}
            options={problem.options}
            correct={problem.correctIndex}
            explanation={problem.explanation}
          />
        </div>
      ))
    }
  </div>
</div>

<style>
  .adaptive-quiz {
    margin: var(--space-xl) 0;
  }

  .quiz-questions {
    display: flex;
    flex-direction: column;
  }

  .quiz-question-wrapper.hidden {
    display: none;
  }

  .quiz-question-wrapper :global(.multiple-choice) {
    margin-top: 0;
  }
</style>

<script>
  // Math is pre-rendered at build time by marked-katex-extension via inlineMarkdown
  function initAdaptiveQuiz(container: HTMLElement) {
    const appendCount = parseInt(container.dataset.appendCount!, 10);

    const allWrappers = Array.from(
      container.querySelectorAll<HTMLElement>(".quiz-question-wrapper"),
    );

    function revealAfter(wrongWrapper: HTMLElement) {
      const hiddenWrappers = allWrappers.filter((w) =>
        w.classList.contains("hidden"),
      );
      const toReveal = hiddenWrappers.slice(0, appendCount);
      if (toReveal.length === 0) return;

      // Insert right after the wrong question
      let insertAfter = wrongWrapper;
      for (const wrapper of toReveal) {
        wrapper.classList.remove("hidden");
        insertAfter.after(wrapper);
        insertAfter = wrapper;
        // Math already rendered at build time, no client-side rendering needed
      }
    }

    // Listen for answer events from MultipleChoice components
    container.addEventListener("mc:answered", ((e: CustomEvent) => {
      if (!e.detail.isCorrect) {
        const wrongWrapper = (e.target as HTMLElement).closest(
          ".quiz-question-wrapper",
        ) as HTMLElement;
        if (wrongWrapper) revealAfter(wrongWrapper);
      }
    }) as EventListener);
  }

  function init() {
    document
      .querySelectorAll<HTMLElement>(".adaptive-quiz")
      .forEach(initAdaptiveQuiz);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
</script>
